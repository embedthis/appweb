/*
    methods.tst - Test cache matching by method

    WARNING: this unit test can fail if your local time is not set correctly.
 */


import {print, thas, ttrue, tget} from 'testme'
import {Http} from 'ejscript'

const HTTP = tget('TM_HTTP') || "127.0.0.1:4100"

/*
    Fetch twice and test if caching is working
 */
async function cached(method, uri): Promise<Boolean> {
    let http: Http = new Http

    //  Clear cache
    http.setHeader("Cache-Control", "no-cache")
    // console.log('CLEAR', method, HTTP + uri)
    http.connect(method, HTTP + uri)
    await http.finalize()
    //  First fetch
    http.connect(method, HTTP + uri)
    await http.finalize()
    ttrue(http.status == 200)
    let resp = deserialize(http.response)
    let first = resp.number
    // console.log('FIRST', method, HTTP + uri, http.response)

    //  Second fetch
    http.connect(method, HTTP + uri)
    await http.finalize()
    ttrue(http.status == 200)
    resp = deserialize(http.response)
    // console.log('SECOND', method, HTTP + uri, http.response)
    http.close()
    return (resp.number == first)
}

if (thas('ME_ESP')) {
    //  The POST requst should be cached and the GET not
    ttrue(await cached("POST", "/methods/cache.esp"))
    ttrue(!await cached("GET", "/methods/cache.esp"))
}

